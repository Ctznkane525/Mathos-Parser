<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="Mathos Parser : ">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Mathos Parser</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/MathosProject/Mathos-Parser">View on GitHub</a>

          <h1 id="project_title">Mathos Parser</h1>
          <h2 id="project_tagline"></h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/MathosProject/Mathos-Parser/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/MathosProject/Mathos-Parser/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h3>
<a id="welcome-to-mathos-parser" class="anchor" href="#welcome-to-mathos-parser" aria-hidden="true"><span class="octicon octicon-link"></span></a>Welcome to Mathos Parser</h3>

<p><strong>Mathos Parser</strong> is a mathematical expression parser, built on top of the .NET Framework, which allows you to parse all kinds of mathematical expressions, and in addition, add your own custom functions, operators, and variables (see the online demo).</p>

<p>Questions can be asked at Stack Overflow: <a href="http://stackoverflow.com/questions/tagged/mathos-parser">http://stackoverflow.com/questions/tagged/mathos-parser</a></p>

<h2>
<a id="features" class="anchor" href="#features" aria-hidden="true"><span class="octicon octicon-link"></span></a>Features</h2>

<ul>
<li>Parse all kinds of mathematical expressions.</li>
<li>Add conditional statements.</li>
<li>Customize operators. Add/edit existing operators, change behaviour of operators.</li>
<li>Programatically add variables before and on the run time.</li>
<li>Custom own functions with almost unlimited amount of arguments.</li>
<li>Using trig functions: sine, cosine, tangents, and also: arc sine, arc cosine, arc tangent.</li>
<li>Supports almost all of the functions available in System.Math, such as: pow, round, sqrt, rem, abs, and more!</li>
<li>Culture independent. No matter on what machine the library is being used - the same configurations for everyone.</li>
<li>Decimal operations.</li>
<li>And much more!</li>
</ul>

<h2>
<a id="introduction" class="anchor" href="#introduction" aria-hidden="true"><span class="octicon octicon-link"></span></a>Introduction</h2>

<p>Mathos Parser is a part of Mathos Project, a project that provides useful methods, structures, etc, to make the life a little bit easier! This math parser is fully independent of Mathos project, so you can just use this library to archive a powerful math parsing experience.</p>

<h2>
<a id="how-to-use" class="anchor" href="#how-to-use" aria-hidden="true"><span class="octicon octicon-link"></span></a>How to use</h2>

<p>It's really easy to use and understand this math parser. In this topic I will try to show you some (not all) key features of this library.</p>

<ul>
<li>Adding a custom operator.</li>
<li>Adding a custom function.</li>
<li>Functions with more than one argument.</li>
<li>Programatically add variables.</li>
</ul>

<h3>
<a id="adding-custom-operator" class="anchor" href="#adding-custom-operator" aria-hidden="true"><span class="octicon octicon-link"></span></a>Adding custom operator</h3>

<pre><code>// declaring the parser
MathParser parser = new MathParser();

//customize the operator list
parser.OperatorList = new List&lt;string&gt;() { "^", "%", "*", ":", "/", "+", "-", "&gt;", "&lt;", "=" };

// adding sqrt to the OperatorAction list
parser.OperatorAction.Add("^", delegate(decimal numA, decimal numB)
{
    return (decimal)Math.Pow((double)numA, (double)numB);
});

// parsing and comparing
Assert.IsTrue(parser.Parse("3^2") == (decimal)Math.Pow (3,2));
</code></pre>

<h3>
<a id="adding-custom-function" class="anchor" href="#adding-custom-function" aria-hidden="true"><span class="octicon octicon-link"></span></a>Adding custom function</h3>

<pre><code>public void CustomFunctions()
{
    /*
     * This test demonstrates three ways of adding a function
     * to the Math Parser
     * 
     * 1) directly pointing to the function
     * 2) lambda expression
     * 3) anonymous method
     */

    MathParser parser = new MathParser();

    //for long functions
    parser.LocalFunctions.Add("numberTimesTwo", NumberTimesTwoCustomFunction); // adding the function
    decimal resultA = parser.Parse("numberTimesTwo(3)");

    //for short functions, use lambda expression, or anonymous method
    // 1) using lambda epxression (recommended)
    parser.LocalFunctions.Add("square", x =&gt; x[0] * x[0]);
    decimal resultB = parser.Parse("square(4)");

    // 2) using anonymous method
    parser.LocalFunctions.Add("cube", delegate(decimal[] x)
    {
        return x[0] * x[0] * x[0];
    });
    decimal resultC = parser.Parse("cube(2)");

}
public decimal NumberTimesTwoCustomFunction(decimal[] input)
{
    return input[0] * 2;
}
</code></pre>

<h3>
<a id="functions-with-more-than-one-operator" class="anchor" href="#functions-with-more-than-one-operator" aria-hidden="true"><span class="octicon octicon-link"></span></a>Functions with more than one operator</h3>

<pre><code>/*
 * This example demonstrates the "anonymous method" way of adding
 * a function that can take more than one agument.
 */

 MathParser parser = new MathParser();

//for long functions
parser.LocalFunctions.Add("log", delegate(decimal[] input) // adding the function
{
    // input[0] is the number
    // input[1] is the base

  if (input.Length == 1)
  {
      return (decimal)Math.Log((double)input[0]);
  }
  else if (input.Length == 2)
  {
      return (decimal)Math.Log((double)input[0], (double)input[1]);
  }
  else
  {
      return 0; // false
  }
});

decimal resultA = parser.Parse("log(2)");
decimal resultB = parser.Parse("log(2,3)");
</code></pre>

<h3>
<a id="programatically-add-variables" class="anchor" href="#programatically-add-variables" aria-hidden="true"><span class="octicon octicon-link"></span></a>Programatically add variables</h3>

<pre><code>/* 
* when parsing an expression that requires 
* for instance a variable name declaration 
* or change, use ProgramaticallyParse().
*/
MathParser parser = new MathParser();

// first way, using let varname = value
decimal resultA = parser.ProgrammaticallyParse("let a = 2pi");
Assert.IsTrue (parser.Parse ("a") == (decimal)Math.PI*2);

// second way, using varname :=  value
decimal resultC = parser.ProgrammaticallyParse("b := 20");
Assert.IsTrue(parser.Parse("b") == 20);

// third way, using let varname be value
decimal resultD = parser.ProgrammaticallyParse("let c be 25");
Assert.IsTrue(resultD == 25);
</code></pre>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Mathos Parser maintained by <a href="https://github.com/MathosProject">MathosProject</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
