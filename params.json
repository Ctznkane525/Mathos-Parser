{"name":"Mathos Parser","tagline":"","body":"###Welcome to Mathos Parser \r\n\r\n**Mathos Parser** is a mathematical expression parser, built on top of the .NET Framework, which allows you to parse all kinds of mathematical expressions, and in addition, add your own custom functions, operators, and variables (see the online demo).\r\n\r\nQuestions can be asked at Stack Overflow: http://stackoverflow.com/questions/tagged/mathos-parser\r\n##Features\r\n\r\n* Parse all kinds of mathematical expressions.\r\n* Add conditional statements.\r\n* Customize operators. Add/edit existing operators, change behaviour of operators.\r\n* Programatically add variables before and on the run time.\r\n* Custom own functions with almost unlimited amount of arguments.\r\n* Using trig functions: sine, cosine, tangents, and also: arc sine, arc cosine, arc tangent.\r\n* Supports almost all of the functions available in System.Math, such as: pow, round, sqrt, rem, abs, and more!\r\n* Culture independent. No matter on what machine the library is being used - the same configurations for everyone.\r\n* Decimal operations.\r\n* And much more!\r\n\r\n##Introduction\r\n\r\nMathos Parser is a part of Mathos Project, a project that provides useful methods, structures, etc, to make the life a little bit easier! This math parser is fully independent of Mathos project, so you can just use this library to archive a powerful math parsing experience.\r\n\r\n##How to use\r\n\r\nIt's really easy to use and understand this math parser. In this topic I will try to show you some (not all) key features of this library.\r\n\r\n* Adding a custom operator.\r\n* Adding a custom function.\r\n* Functions with more than one argument.\r\n* Programatically add variables.\r\n\r\n###Adding custom operator\r\n\r\n````\r\n// declaring the parser\r\nMathParser parser = new MathParser();\r\n\r\n//customize the operator list\r\nparser.OperatorList = new List<string>() { \"^\", \"%\", \"*\", \":\", \"/\", \"+\", \"-\", \">\", \"<\", \"=\" };\r\n\r\n// adding sqrt to the OperatorAction list\r\nparser.OperatorAction.Add(\"^\", delegate(decimal numA, decimal numB)\r\n{\r\n    return (decimal)Math.Pow((double)numA, (double)numB);\r\n});\r\n\r\n// parsing and comparing\r\nAssert.IsTrue(parser.Parse(\"3^2\") == (decimal)Math.Pow (3,2));\r\n````\r\n###Adding custom function\r\n````\r\npublic void CustomFunctions()\r\n{\r\n    /*\r\n     * This test demonstrates three ways of adding a function\r\n     * to the Math Parser\r\n     * \r\n     * 1) directly pointing to the function\r\n     * 2) lambda expression\r\n     * 3) anonymous method\r\n     */\r\n\r\n    MathParser parser = new MathParser();\r\n\r\n    //for long functions\r\n    parser.LocalFunctions.Add(\"numberTimesTwo\", NumberTimesTwoCustomFunction); // adding the function\r\n    decimal resultA = parser.Parse(\"numberTimesTwo(3)\");\r\n\r\n    //for short functions, use lambda expression, or anonymous method\r\n    // 1) using lambda epxression (recommended)\r\n    parser.LocalFunctions.Add(\"square\", x => x[0] * x[0]);\r\n    decimal resultB = parser.Parse(\"square(4)\");\r\n\r\n    // 2) using anonymous method\r\n    parser.LocalFunctions.Add(\"cube\", delegate(decimal[] x)\r\n    {\r\n        return x[0] * x[0] * x[0];\r\n    });\r\n    decimal resultC = parser.Parse(\"cube(2)\");\r\n\r\n}\r\npublic decimal NumberTimesTwoCustomFunction(decimal[] input)\r\n{\r\n    return input[0] * 2;\r\n}\r\n````\r\n###Functions with more than one operator\r\n````\r\n/*\r\n * This example demonstrates the \"anonymous method\" way of adding\r\n * a function that can take more than one agument.\r\n */\r\n\r\n MathParser parser = new MathParser();\r\n\r\n//for long functions\r\nparser.LocalFunctions.Add(\"log\", delegate(decimal[] input) // adding the function\r\n{\r\n    // input[0] is the number\r\n    // input[1] is the base\r\n\r\n  if (input.Length == 1)\r\n  {\r\n      return (decimal)Math.Log((double)input[0]);\r\n  }\r\n  else if (input.Length == 2)\r\n  {\r\n      return (decimal)Math.Log((double)input[0], (double)input[1]);\r\n  }\r\n  else\r\n  {\r\n      return 0; // false\r\n  }\r\n});\r\n\r\ndecimal resultA = parser.Parse(\"log(2)\");\r\ndecimal resultB = parser.Parse(\"log(2,3)\");\r\n````\r\n###Programatically add variables\r\n```\r\n/* \r\n* when parsing an expression that requires \r\n* for instance a variable name declaration \r\n* or change, use ProgramaticallyParse().\r\n*/\r\nMathParser parser = new MathParser();\r\n          \r\n// first way, using let varname = value\r\ndecimal resultA = parser.ProgrammaticallyParse(\"let a = 2pi\");\r\nAssert.IsTrue (parser.Parse (\"a\") == (decimal)Math.PI*2);\r\n\r\n// second way, using varname :=  value\r\ndecimal resultC = parser.ProgrammaticallyParse(\"b := 20\");\r\nAssert.IsTrue(parser.Parse(\"b\") == 20);\r\n\r\n// third way, using let varname be value\r\ndecimal resultD = parser.ProgrammaticallyParse(\"let c be 25\");\r\nAssert.IsTrue(resultD == 25);\r\n```","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}